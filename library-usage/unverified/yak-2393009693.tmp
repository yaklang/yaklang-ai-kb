# Yaklang UDP 通信教程

本教程将基于您提供的代码示例，详细介绍如何在 Yaklang 中使用 UDP 协议进行网络通信。我们将涵盖以下内容：

1. **UDP 基础知识**
2. **代码解析与扩展**
3. **异步编程模型**
4. **最佳实践与注意事项**

---

## 1. UDP 基础知识

UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点：
- **优点**：低延迟、小开销，适合实时性要求高的场景（如视频流、在线游戏等）。
- **缺点**：不保证数据包的顺序、完整性和可靠性。

Yaklang 提供了一套简单易用的 UDP 接口，帮助开发者快速实现 UDP 通信。

---

## 2. 代码解析与扩展

### 原始代码
```yaklang
host, port = "127.0.0.1", os.GetRandomAvailableTCPPort()
go func {
    udp.Serve(host, port, udp.serverCallback((conn, data) => {
        dump(data)
        conn.Write("UDP Message From Server")
    }), udp.serverContext(context.Seconds(2)))
}

sleep(1)
conn = udp.Connect(host, port)~
conn.Send("UDP Message From Client")
waitAllAsyncCallFinish()
```

### 代码解析
1. **获取随机端口**
   ```yaklang
   host, port = "127.0.0.1", os.GetRandomAvailableTCPPort()
   ```
   - `os.GetRandomAvailableTCPPort()` 获取一个随机可用的 TCP 端口。
   - 注意：这里应使用 `os.GetRandomAvailableUDPPort()` 获取 UDP 端口。

2. **启动 UDP 服务器**
   ```yaklang
   go func {
       udp.Serve(host, port, udp.serverCallback((conn, data) => {
           dump(data)
           conn.Write("UDP Message From Server")
       }), udp.serverContext(context.Seconds(2)))
   }
   ```
   - 使用 `udp.Serve` 启动一个 UDP 服务器。
   - `udp.serverCallback` 定义了处理客户端消息的回调函数。
   - 回调函数中，`dump(data)` 打印接收到的数据，`conn.Write` 向客户端发送响应。
   - `udp.serverContext(context.Seconds(2))` 设置服务器上下文超时时间为 2 秒。

3. **客户端连接与通信**
   ```yaklang
   sleep(1)
   conn = udp.Connect(host, port)~
   conn.Send("UDP Message From Client")
   waitAllAsyncCallFinish()
   ```
   - `sleep(1)` 确保服务器完全启动。
   - `udp.Connect` 创建到服务器的连接。
   - `conn.Send` 向服务器发送消息。
   - `waitAllAsyncCallFinish` 等待所有异步调用完成。

---

### 扩展功能
为了增强代码的功能性和实用性，可以添加以下功能：

#### (1) 接收服务器响应
在客户端接收服务器的响应，并打印出来：
```yaklang
data = conn.Recv()~
println(f"Message from server: ${string(data)}")
```

#### (2) 设置超时时间
为客户端设置超时时间，避免长时间阻塞：
```yaklang
conn.SetTimeout(2) // 超时时间为 2 秒
```

#### (3) 错误处理
增加错误处理机制，确保程序的健壮性：
```yaklang
result, err = riskyCall()
if err != nil {
    die(err)
}
```

---

## 3. 异步编程模型

Yaklang 支持协程（goroutine）和并发控制，使得异步编程更加高效。

### (1) 协程（Goroutine）
使用 `go` 关键字启动协程：
```yaklang
go func {
    println("This is a goroutine")
}()
```

### (2) 并发控制
使用 `sync.NewWaitGroup` 控制并发任务：
```yaklang
wg := sync.NewWaitGroup()
wg.Add(1)

go func {
    defer wg.Done()
    println("Task completed")
}()

wg.Wait()
```

---

## 4. 最佳实践与注意事项

### (1) 随机端口选择
- 使用 `os.GetRandomAvailableUDPPort()` 获取随机 UDP 端口。
- 确保端口未被占用，避免冲突。

### (2) 异步启动服务器
- 使用 `go` 启动服务器，确保客户端有足够时间连接。
- 添加 `sleep` 等待服务器启动完成。

### (3) 数据清理
在处理接收到的数据时，可以使用 `str.Trim` 和 `str.TrimSpace` 清理多余字符：
```yaklang
cleanData = str.TrimSpace(string(data))
println(cleanData)
```

### (4) 性能优化
- 优先使用 `TrimSpace` 处理空白字符。
- 缓存常用字符集合，减少重复计算。

---

## 5. 完整示例代码

以下是扩展后的完整代码示例：
```yaklang
// 获取随机 UDP 端口
host, port = "127.0.0.1", os.GetRandomAvailableUDPPort()

// 启动 UDP 服务器
go func {
    udp.Serve(host, port, udp.serverCallback((conn, data) => {
        println(f"Message from client

